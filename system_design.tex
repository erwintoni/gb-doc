\Chapter{System Design}

\section{Design Overview}
GradeBadge application uses a client-server architecture model, and it uses MVC (Model View Controller) architecute in the client and server side. And all incoming AJAX requests are submitted using HTTP POST and contain data encoded using JSON.    

\section{Model View Controller Architecture}
This application is based on Model View Controller (MVC) Architecture. Model View Controller (MVC) architecture is a software design pattern for separating different components of a software application \cite{MVC}. There are three main categories in the MVC architecture:

\begin{itemize}
\item Model : it represents data in the application. All the business rules are handled in the model.
\item View: it represents UI components in the application. The UI components are responsible for presenting the model and for collecting user inputs.
\item Controller: it is responsible for updating the data in the model and notifying the view about changes in the model.
\end{itemize}

\section{Bandwidth Reduction Strategy}
Following sections are the three strategies that are implemented to reduce and effectively use the bandwidth.  

\subsection{File Compression}
In this application, in order to reduce the bandwidth from the server, files that are transferred from the application  will be compressed in gzip format if the client browser supported it which will result to smaller file size. 

\begin{lstlisting}
  if (file.gzip !== undefined && 
      req.headers['accept-encoding'] !== undefined && 
      req.headers['accept-encoding'].indexOf('gzip') !== -1) {
    return app_http.replyCached(res, file.gzip, file.type, 
                                file.etag, 'gzip');
  } else {
    return app_http.replyCached(res, file.data, 
                     file.type, file.etag);
  }
\end{lstlisting}

Also the server will check if the files are not modified by comparing the etag value that will be part of caching strategy.
\begin{lstlisting}
  if (req.headers['if-none-match'] === file.etag) {
    return app_http.replyNotModified(res);
  }
\end{lstlisting}

\subsection{Content Distribution Network Resource}
In this application, we are using Content Distribution Network (CDN) resources instead of storing those files in the server. So client browser will get it from the CDN rather than request them from the application server.  

The following HTML element is used in the application to load the bootstrap CSS file from CDN.
\begin{lstlisting}
<link href="//netdna.bootstrapcdn.com/twitter-bootstrap/
    2.2.2/css/bootstrap.css" rel="stylesheet">
\end{lstlisting}

\subsection{Caching}
In this application, we implemented the cache strategy where every request will be checked whether the file has been modified or is cached in the client browser. Etag value of the file is compared to decide whether the file has been modified or not. This strategy is implemented to reduce unneccesary bandwidth from the server

The following are the four possibilities of the respond from the server as HTTP header, the sample codes are taken from app{\_}http.js file. 

\begin{itemize}
\item Reply Not Found: This is the respond when the requested file is not found, and the server is going to return 404 Not Found to client.  

\begin{lstlisting}
res.writeHead(404, {});
\end{lstlisting}

\item Reply Not Modified: This is the respond when the requested file is not modified, where the etag value is still the same. 

\begin{lstlisting}
res.writeHead(304, {
    'Connection'       : 'keep-alive',
    'Proxy-Connection' : 'keep-alive',
    'Cache-Control'    : 'max-age=31536000',
    'Expires'          : new Date(Date.now() + 31536000000)
  });
\end{lstlisting}

\item Reply Not Cached: This is the respond when the requested file is not cached in the client browser. 

\begin{lstlisting}
res.writeHead(200, {
    'Content-Type'     : 'text/html',
    'Content-Length'   : buffer.length,
    'Connection'       : 'keep-alive',
    'Proxy-Connection' : 'keep-alive',
    'Pragma'           : 'no-cache',
    'Cache-Control'    : 'no-cache, no-store'
  });
\end{lstlisting}

\item Reply Cached: This is the respond when the requested file is cached in the client browser, then the server will update the expiration date of the file.

\begin{lstlisting}
if(contentEncoding) {
    res.writeHead(200, {
      'Content-Type'     : contentType,
      'Content-Length'   : buffer.length,
      'Connection'       : 'keep-alive',
      'Proxy-Connection' : 'keep-alive',
      'Pragma'           : 'public',
      'Cache-Control'    : 'max-age=31536000',
      'Vary'             : 'Accept-Encoding',
      'Expires'          : new Date(Date.now() + 31536000000),
      'ETag'             : etag,
      'Content-Encoding' : contentEncoding
    });
  } else {
    res.writeHead(200, {
      'Content-Type'     : contentType,
      'Content-Length'   : buffer.length,
      'Connection'       : 'keep-alive',
      'Proxy-Connection' : 'keep-alive',
      'Pragma'           : 'public',
      'Cache-Control'    : 'max-age=31536000',
      'Vary'             : 'Accept-Encoding',
      'Expires'          : new Date(Date.now() + 31536000000),
      'ETag'             : etag
    });
  }\end{lstlisting}

\end{itemize}


\section{Server-side Architecture Design}

In Nodejs, components are organized in modules, in the form of namespace. All Nodejs modules that start with req{\_}*.js are request handler that get requested from router.js. All ajax requests will go through req{\_}op.js, that verifies the user logged-in to Facebook and app{\_}version is current. Every req{\_}op.js request must contains Facebook access{\_}token and app{\_}version. If the user is not logged-in to Facebook, req{\_}op.js returns the following JSON document, {login:true}, if the version is not current, then req{\_}op.js return the following JSON document, {ver:true}. 

\subsection{Configuration}
Following are the list of configuration files required in the server side, and the source-code of these files can be found in the Appendix A.

\begin{itemize}
\item .env : This is the setup file that contains environment variables. This file only exist in developer local environment, and these values in this file would be set in each Heroku environment config for staging and production.

Following is the environment variable values in development environment.
\begin{lstlisting}
FB_APP_ID=466760923387961
FB_SECRET=75e7a042473a989a3b876d3ec8749920
PORT=5000
APP_VER=2
MONGO_URI=mongodb://app:gradebadge123@ds045757.mongolab.com:45757/gb-d
\end{lstlisting} 

\item .gitignore: This is the setup file that contains list of files or folders that will be ignored when committing or pushing to git repositories. 
\item .slugignore: This is the setup file that contains list of files or folders that will be ignored when calculating the slug limit in Heroku
\item package.json: This is the setup file that contains of list of dependencies and engine version use in the application. This file also contains application name, version and description, as shown in the following. 
\begin{lstlisting}
{
    "name": "gradebadge",
    "version": "0.0.1",
    "description": "Grade Badge System",
    "dependencies": {
        "mongodb": "1.2.13"
    },
    "engines": {
        "node": "0.8.21",
        "npm": "1.2.12"
    }
}
\end{lstlisting} 

\item Procfile: This is the setup file that tells Heroku how to launch the application, as shown in the followgin.
\begin{lstlisting}
web: node main.js
\end{lstlisting} 

\end{itemize}

\subsection{Nodejs Module}
The following list below are the list of files that are used in server executions, and the source-code of these files can be found in the Appendix A.

\begin{itemize}
\item main.js: This is the main module in node js, which contains the code that verify all neccessary environment variables are set correctly. It also invoke initialization in neccesarry modules to start the application, after the initialization is completed, it starts the HTTP request handling loop, as shown in the following.
\begin{lstlisting}
var n = 3;
function done() {
  if (--n === 0) {
    router.start();
  }  
}
model  .init(done);
router .init(done);
fb     .init(done);
\end{lstlisting} 

\item router.js: This module routes incoming requests to the right module, as shown in the following.
\begin{lstlisting}
function route(req, res) {
  var pathname = url.parse(req.url).pathname;
  if      (pathname === '/') req_root.handle(req, res)
  else if (pathname === verpath) req_app.handle(req, res)
  else if (pathname === issuerpath) req_issuer.handle(req, res)
  else if (pathname === '/mem')  req_mem.handle(req, res)
  else if (pathname === '/counters') req_counters.handle(req, res)
  else req_rootdir .handle(req, res);
}
\end{lstlisting} 


\item app{\_}ajax.js: This module contains the application wide AJAX handling routines. Following is the sample function of Ajax respond that would send data back to client
\begin{lstlisting}
exports.data = function(res, data) {
  if (data === undefined) {
    data = {};
  }
  var buf = new Buffer(JSON.stringify({'data' : data}), 'utf8');
  res.writeHead(200, {
    'Content-Type': 'application/json; charset=UTF-8',
    'Content-Length': buf.length,
    'Pragma': 'no-cache',
    'Cache-Control': 'no-cache, no-store'
  });
  res.end(buf);
};
\end{lstlisting} 


\item app{\_}http.js: This module contains all of HTTP protocol routines for the application, caching headers, compression header and other HTTP based optimization are implemented in this module. This file was discussed in the caching strategy section.

\item fb.js: This module contains all code that interact with Facebook. Following is the sample of initialization function, that will check Facebook App ID and secret below.
\begin{lstlisting}
exports.init = function(cb) {  
  var options = {
    hostname: 'graph.facebook.com',
    path: '/oauth/access_token?' + 
          'client_id=' + process.env.FB_APP_ID +
          '&client_secret=' + process.env.FB_SECRET +
          '&grant_type=client_credentials',
    method: 'GET'
  };
  send(options, function(data) {
    if (data instanceof Error) {
      throw data;
    }
    if (data.access_token === undefined) {
      throw new Error(
        'fb.init: access_token not returned by facebook.' +
        '\nfb.init: Facebook returned: ' + JSON.stringify(data)
      );
    }
    appToken = data.access_token;
    cb(appToken);
  });
};
\end{lstlisting} 


\item logger.js: This module contains application wide logging functionalities. Following is the sample of error loggin function in this module.
\begin{lstlisting} 
exports.errors = function(msg, opt_msg) {
  if (errorsPrinted < process.env.LOGGER_MAX_ERRORS) {
    ++errorsPrinted;
    print('ERROR', msg, opt_msg);
    if (errorPrinted == process.env.LOGGER_MAX_ERROR) {
      console.log('MAX ERROR HIT');
    }
  }
  ++exports.errorsReceived;
};
\end{lstlisting} 

\item model.js: This module initializes the database connnection pool during server start 

\item req{\_}app.js: This module handles request for application HTML template for badge earner
\item req{\_}counter.js: This module handles request for logging counter 
\item req{\_}file.js: This module handles request for static content.
\item req{\_}issuer.js: This module handles request for application HTML template for badge issuers
\item req{\_}mem.js: This module handles request for memory usage
\item req{\_}root.js: This module handles request for static content under the root URL
\item req{\_}op.js : This module handles all AJAX request from client and routes to appropriate modules.  
\end{itemize}


\section{Mapping of Model Classes to MongoDB}
There will be one node js module to represent the mongoDB collection, named model{\_}(collection{\_}name).js. And many-to-many relationships are represented by linking documents, named (a){\_}(b){\_}links


The following list below are the list of files that are used to Model to represent MongoDB, and the source-code of these files can be found in the Appendix B

\begin{itemize}
\item model{\_}group.js: this node.js module represents Groups collection
\item model{\_}badge.js: this node.js module represents Badges colletion
\item model{\_}user.js: this node.js module represents Users collection
\item model{\_}group{\_}admin.js: this node.js module represents group{\_}admin{\_}links collection
\item model{\_}group{\_}member.js: this node.js module represents group{\_}member{\_}links collection
\item model{\_}user{\_}badge.js: this node.js module represents user{\_}badge{\_}links collection
\item model{\_}group{\_}badge.js: this node.js module represents group{\_}badge{\_}links collection
\end{itemize}

\section{Request Handler Operation}
There will be one node js module to handle ajax request from client, named op{\_}(request).js. Every request may read, write or update to and from more than one collection


The following list below are the list of files that are used in request handler operation, and the source-code of these files can be found in the Appendix C

\begin{itemize}
\item op{\_}read{\_}badges{\_}by{\_}group.js: this operation is for request for all badges in the given group
\item op{\_}read{\_}groups{\_}by{\_}admin.js: this operation is for request for all groups in the given admin
\item op{\_}save{\_}badge.js: this operation is for request for saving given badge details
\item op{\_}save{\_}group.js: this operation is for request for saving given group details
\end{itemize}

\section{Client-side Architecutre Design}
The following list below are the list of files that are used in client-side execution, and the source-code of these files can be found in the Appendix D

\begin{itemize}
\item app.html : This is the html template for badge earner page
\item issuer.html : This is the html template for badge issuer page
\item public{\_}root/channel.html : This is the static content required by Facebook 
\item public{\_}root/favicon.ico : This is the statuc content for icon use in the browser
\item public{\_}ver/app.js : This is the client java-script  
\item public{\_}ver/style.css: This is the css file use
\end{itemize}
